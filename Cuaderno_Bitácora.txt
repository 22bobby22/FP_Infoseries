[02/01/2020]

0. Documentación en cuaderno de bitácora (1 hora)
5.2.1. Crear la base de datos en Firebase (4 horas)

	- Leer documentación de firebase

		Primero he leído la documentación y una guía de inicio en firebase.google.com para crear un proyecto en Firebase y agregarlo al proyecto Android.

	- Crear proyecto Firebase y conectar con Android

		Para realizar esta tarea he seguido los siguientes pasos:

			- En console.firebase.google.com he creado un nuevo proyecto al que he llamado infoseries-firebase.
			- Con Android Studio he creado el proyecto Android con una actividad principal vacía al que he asignado un nivel de 
			  API mínimo de 16 (requisito de Firebase).
			- En la consola de Firebase he registrado la aplicación Android que acabo de crear y he descargado el archivo de 
			  configuración google-services.json.
			- En el proyecto Android, después de añadir el archivo de configuración he añadido el SDK de Firebase al gradle.
			- Por último he ejecutado la aplicación para verificar que se ha instalado y todo funciona correctamente. Para poder 
			  ejecutar la aplicación he tenido que crear un dispositivo virtual con el AVD Manager de Android Studio y habilitar
			  la virtualización en la BIOS.

	- Curso de Udacity sobre Firebase

		Antes de empezar a crear una base de datos en Firebase he decidido hacer un curso gratuito en www.udacity.com llamado Firebase in a weekend en el que he aprendido:

			- Firebase almacena los datos en objetos JSON.
			- Los ID de los objetos son únicos y creados por Firebase, se llama pushed IDs. De esta forma si dos dispositivos
			  envían datos al mismo tiempo, como el ID lo crea Firebase, se asegura que el ID va a ser diferente para estos datos.
			- Para trabajar con imágenes hay que añadir la dependencia 'com.github.bumptech.glide:glide'.
			- En la actividad principal hay que crear los siguientes atributos para trabajar con Firebase: FirebaseDatabase fbDb
			  (referencia a toda la base de datos de Firebase) y DatabaseReference dbR (referencia a una parte específica de la
			  base de datos).
			- Para crear una instancia de la base de datos: fbDb = FirebaseDatabase.getInstance().
			- Para crear la instancia de una parte específica: dbR = fbDb.getReference().child(String nombre)
			- Para enviar datos a la base de datos: dbR.push().setValue(Object objeto)
			- Mientras que la autenticación de usuario no está implementado hay que cambiar las reglas de seguridad de Firebase a
			  "true" para poder hacer pruebas.

[Fin del día]




[08/01/2020]

0. Documentación en cuaderno de bitácora (15 minutos)
1.1. Documentación en memoria de la motivación del proyecto (15 minutos)
1.2. Documentación en memoria del resumen en inglés (1 hora)
1.3. Documentación en memoria de los objetivos generales y específicos del proyecto (1 hora)
2. Documentación en memoria de la metodología utilizada (1 hora)
3. Documentación en memoria de las tecnologías y herramientas utilizadas en el proyecto (1 hora)
4. Documentación en memoria de la estmiación de recursos y planificación (1 hora)
5.1. Documentación en memoria del análisis del proyecto (3 horas)

[Fin del día]




[09/01/2020]

0. Documentación en cuaderno de bitácora (1 hora 30 minutos)
5.1. Documentación en memoria del análisis del proyecto (1 hora)

	He analizado los requisitos funcionales de la aplicación pero no los no funcionales.

5.2.1. Crear la base de datos en Firebase (3 horas 30 minutos)
		
		- Curso de Udacity sobre Firebase
			He seguido con el curso de Firebase en el que he aprendido:

				- Normalmente habría que estar comprobando continuamente si hay algún cambio en la base de datos, pero con
				  Firebase, es Firebase quien se encarga de informar de forma proactiva a todos los dispositivos que ha habido un
				  cambio.
				- Para que la aplicación sepa cuando Firebase le dice que se ha realizado un cambio se debe implementar un
				  ChildEventListener. Después hay que sobreescribir los métodos del ChildEventListener para indicar lo que la
				  aplicación debe hacer, dependiendo del tipo de cambio que haya ocurrido en la base de datos (add, 
				  change o remove) la aplicación debe hacer cosas distintas. Por último hay que añadir a la referencia de la base
				  de datos el ChildEventListener dbR.addChildEventListener(cEL).
				- He aprendido sobre cómo configurar las reglas de seguridad en Firebase.
				- Con FirebaseUI puedes habilitar muchas formas de autenticación de usuarios como Google, Facebook, Email, etc.
				- Para utilizar FirebaseUI debes habilitar las formas de autenticación que quieres usar en la consola de
				  Firebase, añadir las dependencias necesarias e implementar en el código de la aplicación la autenticación de
				  usuarios.
				- En este punto he dejado el curso de Firebase de lado puesto que los siguientes pasos en el curso son la 
				  implementación de la autenticación de usuarios, y el almacenamiento de imágenes, ambas son funcionalidades que
				  planeo implementar más adelante en el proyecto. Pero, de momento quiero simplemente crear los datos en la base
				  de datos y crear la actividad principal de la aplicación.

		- Implementación del sistema de autenticación de usuarios
		
			He activado en mi consola de Firebase la autenticación con cuenta de Google ya que es la única que me he propuesto implementar para la realización del proyecto. Para ello he tenido que buscar el certificado SHA-1 de la aplicación y añadirlo a la configuración del proyecto en Firebase.

			Después hay que implementar la autenticación en la aplicación, para ello voy a usar una librería llamada FirebaseUI que facilita esta implementación. Para usar esta librería he añadido las dependencias necesarias al proyecto (com.firebaseui:firebase-ui-auth y com.google.firebase:firebase-auth).

			No voy a seguir implementando el sistema de autenticación de usuarios ya que planeaba implementarlo después de crear la actividad principal.

		- Creación de los datos en Firebase

			Primero voy a crear las estructuras en las que se van a almacenar los datos. Por comodidad voy a crear una actividad con unos EditText y un botón para que envíe datos a Firebase y vaya creando los objetos JSON por su cuenta.

[Fin del día]




[10/01/2020]

0. Documentación en cuaderno de bitácora (30 minutos)
5.2.1. Crear la base de datos en Firebase (4 horas)
	
	- Creación de los datos en Firebase
	
		En el directorio java del proyecto he creado el paquete activities para almacenar las actividades de la aplicación y el paquete models para almacenar los Plain Java Objects (POJOs) de los que va a hacer uso la aplicación para almacenar datos en la base de datos.

		He creado el POJO para la clase Productora con los atributos: nombre, imagen, descripcion, producciones y fecha.

		Para crear una pequeña cantidad de datos para hacer pruebas y empezar a construir la aplicación, he creado primero una interfaz para subir datos a Firebase. Con esta interfaz he subido 2 productoras.

		A parte de aprender como pushear datos a Firebase (utilizo push para que los IDs se generen automáticamente), he tenido varios problemas para poder almacenar el objeto Date de una forma satisfactoria y que cumpla con el formato que quiero (dd/MM/yyyy). Al final, después de bastante tiempo buscando formas de realizar esta tarea, he decidido guardar la fecha usando una variable long en la que almaceno el resultado del método getTime() de la clase Date, ya que es lo que se recomienda. De esta forma, puedo simplificar el almacenamiento de la fecha y puedo transformar en cualquier momento este long a un objeto Date, ya que la clase Date contiene un constructor Date(long).

		He creado el POJO para la clase Serie con los atributos: nombre, productora, imagen, descripcion, temporadas y fecha. Y también el POJO para la clase Película con los atributos: productora, nombre, imagen, descripcion, duracion, fecha.

[Fin del día]




[13/01/2020]

0. Documentación en cuaderno de bitácora (15 minutos)
5.2.1. Crear la base de datos en Firebase (2 horas 30 minutos)

	- Creación de los datos en Firebase

		Respecto a las categorías de las series y las películas, he decidido almacenarlas en las clases Serie y Película, ya que como no tengo necesidad de consultar solamente las categorías de las series para ninguna operación, las puedo almacenar como un String, separando cada categoría con un delimitador para luego poder usar la función split() y obtener un array de String con las categorías. De esta forma las clases Serie y Película siguen siendo POJOs.

		He almacenado 2 películas y 8 series con la interfaz que he creado en la aplicación para mandar datos a Firebase. Con estos datos ya puedo empezar a desarrollar otros aspectos de la aplicación.

		


5.2.2 Creación del RecyclerView de la actividad principal

		Para crear el RecyclerView primero tengo que seguir estos pasos:

			- Añadir la dependencia 'androidx.recyclerview:recyclerview'.
			- Crear el elemento RecyclerView en el recurso xml de la actividad principal.
			- Crear el elemento del que ve a estar compuesto el RecyclerView. Para empezar he creado un recurso xml con un simple
			  TextView dentro de un LinearLayout.
			- Crear un adaptador que es el que se va a encargar de recibir los datos y enviárselos al RecyclerView.

[Fin del día]




[14/01/2020]

0. Documentación en cuaderno de bitácora (30 minutos)
5.2.2. Creación del RecyclerView de la actividad principal (4 horas 30 minutos)

	Para personalizar el RecyclerView lo primero que voy a hacer es coger datos de la base de datos y mostrar al menos el nombre del contenido en los items del RecycleView. Para ello he cogido la referencia de la base de datos del objeto "series", he creado un ValueEventListener que es el que se va a encargar de leer los datos y tratarlos.

	Para probar que tanto la conexión con Firebase como el RecyclerView funcionan correctamente, he pedido los datos de todas las series a Firebase, los he almacenado en una lista, he modificado el adaptador para que su constructor pida una lista y también para que por cada item de la lista muestre el nombre de la serie, he creado un adaptador pasandole la lista de series y he ejecutado la aplicación para comprobar que funciona. [CAPTURA DE PANTALLA 1] Como se puede observar en la captura, funciona como esperaba.

	Después he pasado a modificar la vista de los items del RecyclerView para que muestre más información, concretamente, para que muestre las categorías y una imagen.

	El siguiente problema que me he encontrado es ordenar los datos en orden descendiente por fecha. Firebase sólo permite ordenar por orden ascendiente, por lo que he creado una consulta que me devuelva todas las series en orden ascendiente usando la fecha y he guardado los datos en una lista, luego he utilizado el método Collections.reverse() para que la lista que estaba en orden ascendiente pasase a estar en orden descendiente.

	El siguiente paso es almacenar las imágenes en Firebase y mostrarlas en la aplicación. Para ello voy a usar el storage de Firebase.

	He conseguido hacer que la aplicación se comunique con el storage de Firebase y muestre imágenes usando Glide en un ImageView dentro de un item del RecyclerView. Aunque visualmente no es lo que esperaba puesto que las imágenes son de distintos tamaños y el resultado no es del todo estético, me voy a centrar más en la funcionalidad. No me puedo permitir perder mucho tiempo en la estética del proyecto. [CAPTURA DE PANTALLA 2].

	El siguiente problema que he abordado es el hecho de que de momento el RecyclerView sólo muestra las series y no las películas. Para solucionar esto he juntar la consulta a Firebase que me devuelve las series y la consulta que me devuelve las películas en una sola lista y pasar esa lista al adaptador del RecyclerView. Esto me va a presentar dos problemas, el primero es que quiero que haya alguna diferencia visual en el RecyclerView que indique qué item es una serie y qué item es una película, el segundo problema es que voy a tener que cambiar la forma en la que ordenaba las series en orden descendiente ya que no me a valer en este caso usar el método reverse() de Collections.

	He tenido que cambiar el API level mínimo para poder usar el método sort de Collections.

[Fin del día]




[16/01/2020]

0. Documentación en cuaderno de bitácora (30 minutos)
5.2.2. Creación del RecyclerView de la actividad principal (4 horas)

	En el layout del item del RecyclerView he creado un TextView adicional que indique si el item que se está mostrando es una serie o una película. En el código, tanto en el ValueEventListener de la clase MainActivity como en el onBindViewHolder del MainAdapter, he tenido que hacer una comprobación del tipo de dato que recibo: si tiene el dato que recibo contiene el campo temporadas entonces es una serie, en caso contrario, es una película.

	Para ordenar la lista de datos que se le pasa al MainAdapter he creado un CustomComparator que compare las fechas de los objetos de la lista, ya sean películas o series, y ordene la lista de forma decreciente en base a este campo.

	He rediseñado el layout del item del RecyclerView para que los elementos estén un poco más ordenados. [CAPTURA DE PANTALLA 3].

	Para que cada elemento del RecyclerView cree una actividad en la que se muestre información del elemento clicado, primero he añadido un OnClickListener a los elementos del RecyclerView, de forma que se puedan clicar. En el método onClick del onClickListener se crea un intent al que se le añase un extra de nombre "Serie" o "Pelicula" (depende del dato que toque añadir) e inicie la actividad SerieActivity o PelicuclaActivity, según corresponda.

	He creado dos actividades, y por tanto, dos layouts distintos, porque Serie y Pelicula tienen datos distintos, pocos, pero lo suficiente como para que no pueda usar el mismo layout para representar los datos de los dos objetos.

	Las actividades SerieActivity y PeliculaActivity tiene una estructura similar, primero cogemos la referencia a las vistas del layout, luego cogemos el objeto Serie o Pelicula del intent con getIntent().getSerializableExtra("MyClass") (para poder usar este método, tanto Serie como Pelicula deben implementar la interfaz Serializable), por último cogemos los datos del objeto Serie o Pelicula y se los añadimos a las vistas del layout, formateándolos primero para que sean más legibles.

	Tras seguir estos pasos, el resultado de clicar en un elemento del RecyclerView es el siguiente. [CAPTURA DE PANTALLA 4].

[Fin del día]




[17/01/2020]

0. Documentación en cuaderno de bitácora (30 minutos)
5.2.2. Creación del RecyclerView de la adctividad principal (15 minutos)

	Para mayor legibilidad y simplicaficación del código he creado una clase abstracta Contenido con los atributos: imagen, nombre, descripción, fecha. De esta clase abstracta heredan Serie, Pelicula y Productora.

5.2.3. Implementación de la función de búsqueda (3 horas)

	Primero he creado una carpeta de recursos de tipo menu y en ella he creado el recurso menu_search.xml. En este recurso creo un item android con el icono de una lupa (icono representativo de la función de búsqueda), y que cuando es clicado crea un android.widget.SearchView. Este menu hay que inflarlo en la interfaz de la actividad principal dentro del método onCreateOptionsMenu.

	La primera funcionalidad que he implementado es la de filtrar el contenido que ya está en el RecyclerView, sin necesidad de enviar la cadena de búsqueda. Para ello hay que añadir al SearchView un onQueryTextListener que recoja lo que se está escribiendo en el SearchView y se lo pase al método filtrador de contenido del adaptador del RecyclerView.

	Para que el adaptador pueda filtrar contenido tiene que implementar la interfaz Filterable e implementar el método getFilter(). Par implementar el método getFilter(), que devuelve un filtro, hay que crear un Filter e implementar los métodos performFiltering (coge la cadena de búsqueda y filtra la lista de contenido) y publishResults (devuelve el resultado de filtrar).

	Así queda una simple búsqueda, sin enviar la cadena, sólo escribiéndola: [CAPTURA DE PANTALLA 5].

	Después me he puesto a implementar la búsqueda. Ya que filtrar no es suficiente si quieres buscar productoras, que no están añadidas en el RecyclerView de la actividad principal. Para ello cuando se envía la cadena de búsqueda en el RecyclerView hago una query a la base de datos de Firebase para coger todas las productoras, las añado a la lista del adaptador del RecyclerView y por último filtro la lista de nuevo.

	También he creado una actividad con su respectivo layout para mostrar información sobre una productora.

[Fin del día]




[27/01/2020]

0. Documentación en cuaderno de bitácora (1 hora)
5.2.4. Implementación del sistema de autenticación de usuarios (9 horas)

	Continuo con la implementación del sistema de autenticación de usuarios.

	Las dependencias ya están añadidas, he creado las variables firebaseAuth y firebaseAuthListener. Después he creado la instancia de firebaseAuth y he creado el firebaseAuthListener en la actividad principal, rellenando el método onAuthStateChanged. Este método se ejecuta cuando el usuario se conecta o se desconecta, en él primero compruebo si el usuario está conectado, y luego, si está conectado lo desconecto, si no está conectado le muestro una actividad para que se conecte.

	Al intentar ejecutar la aplicación para probar la autenticación me he encontrado con un problema, la aplicación me pide que actualice los servicios de google play para poder ejecutarse. Resolver este problema me ha llevado bastante tiempo, al final resulta que tenia que descargar unas cosas con el SDK Manager de Android Studio.

	Al ejecutar la aplicación, efectivamente me pide una cuenta de google para poder usar la aplicación. [CAPTURA DE PANTALLA 6]

	Después he implementado una opción en el menu que permita cerrar sesión.

	Cuando un usuario inicia sesión, me guardo el nombre de usuario y creo el recyclerview, ya que he actualizado las reglas de firebase para que no se puedan ni leer ni escribir datos si el usuario no inicia sesión primero. Cuando un usuario cierra sesión, borro los datos del recyclerView y borro el nombre de usuario.

5.2.5. Implementación de la función de marcado y la barra de navegación inferior (2 horas)

	Lo siguiente que voy a implementar es un botón que permita marcar un contenido, de forma que se envia a la base de datos el usuario y el nombre del contenido marcado. Esta información es la que pretendo mostrar en un recyclerview para que el usuario pueda ver en cualquier momento el contenido que tiene marcado.

	He creado un botón en las actividades de contenido (serie, película y productora) con la imagen de una estrella, aunque todavía no he implementado la funcionalidad.

	También he creado un barra de navegación inferior sin funcionalidad, sólo se ve visualmente. [CAPTURAS DE PANTALLA 7 Y 8]

[Fin del día]




[28/01/2020]

0. Documentación en cuaderno de bitácora (15 minutos)
5.2.5. Implementación de la función de marcado y la barra de navegación inferior (6 horas)

	Después de implementarle un poco de funcionalidad a la barra de navegación inferior, como que se puedan clicar los iconos y cambien de color según si están clicados o no, he estado un tiempo modificando los colores de todos los elementos de la aplicación para adaptarlos un poco más a mi gusto personal. [CAPTURA DE PANTALLA 9]

	Lo siguiente que he decidido hacer es seguir con la funcionalidad de marcado, voy a hacer que cuando se clique en el botón con forma de estrella, se inserte información en la base de datos. Para ello voy a crear un nuevo nodo en la base de datos llamado "usuarios", cuyos nodos hijos serán los "pushedIDs" que genera firebase automáticamente, estos últimos tendrán como nodos hijos los campos "marcadores" y "usuario", a su vez, el campo "marcadores" estará compuesto de tantos nodos "marcador" (compuestos por "nombre" y "tipo") como contenido marque el usuario en la aplicación. La estructura quedaría así: [CAPTURA DE PANTALLA 10]

	He creado una clase auxiliar llamada "DatabaseOperations" en un paquete Java llamado "Tools", esta clase contiene métodos necesarios para implementar la funcionalidad de marcado de contenido, como estos métodos van a ser utilizados en distintas actividades, he querido implementarlos en una clase a parte para no tener mucho código duplicado. Estos métodos son: userExists, comprueba si el usuario ha marcado contenido anteriormente o es su primera vez; addUser, añade el usuario a la base de datos; isBookmarked, comprueba si el contenido ya ha sido marcado por el usuario anteriormente; addBookmark, añade el marcador en la base de datos; deleteBookmark, borra el marcador de la base de datos.

[Fin del día]